--- dump978/demodulator.cc      2021-05-07 06:37:39.000000000 -0400
+++ dump978-old/demodulator.cc  2020-08-29 05:18:43.631002854 -0400
@@ -9,6 +9,9 @@
 #include <iomanip>
 #include <iostream>
 
+#define FISB_ONLY 1
+// #define DEBUG_MSGS 1
+
 using namespace flightaware::uat;
 
 SingleThreadReceiver::SingleThreadReceiver(SampleFormat format) : converter_(SampleConverter::Create(format)), demodulator_(new TwoMegDemodulator()) {}
@@ -147,14 +150,14 @@
     return 0;
 }
 
-#ifdef AUTO_CENTER
 // check that there is a valid sync word starting at 'phase'
 // that matches the sync word 'pattern'. Return a pair:
 // first element is true if the sync word looks OK; second
 // element has the dphi threshold to use for bit slicing
 static inline std::pair<bool, std::int16_t> CheckSyncWord(PhaseBuffer::const_iterator phase, std::uint64_t pattern) {
+    //const unsigned MAX_SYNC_ERRORS = 0;
     const unsigned MAX_SYNC_ERRORS = 4;
-
+    
     std::int32_t dphi_zero_total = 0;
     int zero_bits = 0;
     std::int32_t dphi_one_total = 0;
@@ -195,7 +198,6 @@
 
     return {(error_bits <= MAX_SYNC_ERRORS), center};
 }
-#endif
 
 // demodulate 'bytes' bytes from samples at 'phase' using 'center' as the bit
 // slicing threshold
@@ -298,6 +300,7 @@
         if (++sync_bits < SYNC_BITS)
             continue; // haven't fully populated sync0/1 yet
 
+#ifndef FISB_ONLY
         // see if we have (the start of) a valid sync word
         // when we find a match, try to demodulate both with that match
         // and with the next position, and pick the one with fewer
@@ -323,8 +326,12 @@
                 continue;
             }
         }
-
+#endif
+       
         if (SyncWordMatch(sync0, UPLINK_SYNC_WORD)) {
+#ifdef DEBUG_MSGS            
+               std::cout << "# sync0 match" << std::endl;
+#endif
             auto start = probe - SYNC_BITS * 2 + 2;
             auto message = DemodBest(start, false /* !downlink */);
             if (message) {
@@ -336,7 +343,10 @@
         }
 
         if (SyncWordMatch(sync1, UPLINK_SYNC_WORD)) {
-            auto start = probe - SYNC_BITS * 2 + 3;
+#ifdef DEBUG_MSGS            
+               std::cout << "# sync1 match" << std::endl;
+#endif
+               auto start = probe - SYNC_BITS * 2 + 3;
             auto message = DemodBest(start, false /* !downlink */);
             if (message) {
                 probe = message->end - 2;
@@ -367,7 +377,6 @@
 }
 
 boost::optional<Demodulator::Message> TwoMegDemodulator::DemodOneDownlink(PhaseBuffer::const_iterator start) {
-#ifdef AUTO_CENTER
     auto sync = CheckSyncWord(start, DOWNLINK_SYNC_WORD);
     if (!sync.first) {
         // Sync word had errors
@@ -375,9 +384,7 @@
     }
 
     auto result = DemodBits(start + SYNC_BITS * 2, DOWNLINK_LONG_BYTES, sync.second, sync.second);
-#else
-    auto result = DemodBits(start + SYNC_BITS * 2, DOWNLINK_LONG_BYTES, 0, 0);
-#endif
+
     auto &raw = result.first;
     auto &erasures = result.second;
 
@@ -395,29 +402,61 @@
 }
 
 boost::optional<Demodulator::Message> TwoMegDemodulator::DemodOneUplink(PhaseBuffer::const_iterator start) {
-#ifdef AUTO_CENTER
     auto sync = CheckSyncWord(start, UPLINK_SYNC_WORD);
     if (!sync.first) {
         // Sync word had errors
         return boost::none;
     }
 
-    auto result = DemodBits(start + SYNC_BITS * 2, UPLINK_BYTES, sync.second, sync.second);
-#else
-    auto result = DemodBits(start + SYNC_BITS * 2, UPLINK_BYTES, 0, 0);
-#endif
-    auto &raw = result.first;
-    auto &erasures = result.second;
+    std::int16_t center;
+    std::int16_t center_orig = sync.second;   
 
-    bool success;
-    Bytes corrected;
-    unsigned errors;
-    std::tie(success, corrected, errors) = fec_.CorrectUplink(raw, erasures);
+    // increment center this much per iteration 
+    std::int16_t center_incr = 3;
+    //std::int16_t center_incr = 5;
+
+#ifdef DEBUG_MSGS
+    std::cout << "#  -> slice: " << sync.second << std::endl;
+#endif    
+    
+    // center is a good guess to start with, but we always can't decode
+    // from the initial center value. What we do is to slice at levels
+    // above and below center, starting near center and gradually increasing
+    // the range until we match, or run out of loop iterations.
+    for (int i = 0; i < 1201; i++) {
+        if (i == 0) {
+            center = center_orig;
+        }
+        else {
+            if ((i % 2) == 1) {
+                center = center_orig + (center_incr * (((i - 1) / 2) + 1));
+            }
+            else {
+                center = center_orig - (center_incr * (((i - 1) / 2) + 1));
+            }
+        }
+          
+        auto result = DemodBits(start + SYNC_BITS * 2, UPLINK_BYTES, center, center);
 
-    if (!success) {
-        // Error correction failed
-        return boost::none;
+        auto &raw = result.first;
+        auto &erasures = result.second;
+
+        bool success;
+        Bytes corrected;
+        unsigned errors;
+        std::tie(success, corrected, errors) = fec_.CorrectUplink(raw, erasures);
+
+        if (success) {
+            if (i != 0) {
+                std::cout << "#  RECENTER " << center_orig << " -> " << center << " i:" << i << std::endl;
+            }
+
+            return Demodulator::Message{std::move(corrected), errors, start, start + (SYNC_BITS + UPLINK_BITS) * 2};            
+        }
     }
 
-    return Demodulator::Message{std::move(corrected), errors, start, start + (SYNC_BITS + UPLINK_BITS) * 2};
+    // Error correction failed
+    return boost::none;
+
+
 }
